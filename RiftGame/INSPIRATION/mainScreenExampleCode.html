<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RIFT â€“ BREACH MODE (3D)</title>
  <style>
    body { margin: 0; overflow: hidden; background: #02000a; }
    canvas { display: block; }
    /* Cursor styling to hint interactivity */
    body { cursor: default; }
    body.hovering { cursor: pointer; }
  </style>
</head>
<body>

<!-- Import Map for v0.128.0 -->
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
  // Reflector removed for a cleaner look

  // --- 1. Scene Setup ---
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x02000a, 0.02);
  scene.background = new THREE.Color(0x02000a);

  const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 3, 22);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2; 
  document.body.appendChild(renderer.domElement);

  // --- 2. Post-Processing ---
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.5,
    0.4, 
    0.0 
  );
  composer.addPass(bloomPass);

  const glitchPass = new GlitchPass();
  glitchPass.enabled = true; 
  glitchPass.goWild = false;
  composer.addPass(glitchPass);

  // --- 3. Environment ---
  const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
  scene.add(ambientLight);

  const spotLight = new THREE.SpotLight(0xffffff, 1);
  spotLight.position.set(0, 20, 10);
  spotLight.angle = 0.3;
  spotLight.penumbra = 1;
  spotLight.intensity = 1.5;
  scene.add(spotLight);

  // REPLACED MIRROR WITH MATTE FLOOR
  const floorGeo = new THREE.PlaneGeometry(500, 500);
  const floorMat = new THREE.MeshStandardMaterial({ 
    color: 0x050505, 
    roughness: 0.8, 
    metalness: 0.2 
  });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -5;
  scene.add(floor);

  const gridHelper = new THREE.GridHelper(500, 60, 0xaa00ff, 0x220044);
  gridHelper.position.y = -4.9;
  gridHelper.material.transparent = true;
  gridHelper.material.opacity = 0.15; 
  scene.add(gridHelper);

  // Stars
  const starsGeo = new THREE.BufferGeometry();
  const starCount = 3000;
  const posArray = new Float32Array(starCount * 3);
  for(let i = 0; i < starCount * 3; i++) {
    posArray[i] = (Math.random() - 0.5) * 400;
    if (i % 3 === 1 && posArray[i] < 0) posArray[i] *= -1; 
  }
  starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({ color: 0x88aaff, size: 0.2 }));
  scene.add(stars);

  // --- 4. The 3D "BREACH" Button ---
  const buttonGroup = new THREE.Group();
  scene.add(buttonGroup);
  
  buttonGroup.position.set(0, -3.5, 8); 
  buttonGroup.rotation.x = 0.2; 

  // Button Base
  const baseGeo = new THREE.CylinderGeometry(3.5, 4, 1, 6); 
  const baseMat = new THREE.MeshStandardMaterial({ 
    color: 0x222222, 
    roughness: 0.5, 
    metalness: 0.7 
  });
  const baseMesh = new THREE.Mesh(baseGeo, baseMat);
  baseMesh.position.y = -0.5;
  buttonGroup.add(baseMesh);

  // Button Cap (Red Dome)
  const capGeo = new THREE.SphereGeometry(2.8, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
  const capMat = new THREE.MeshStandardMaterial({
    color: 0xaa0000,
    emissive: 0xff0000,
    emissiveIntensity: 0.5,
    roughness: 0.4,
    metalness: 0.3,
  });
  const capMesh = new THREE.Mesh(capGeo, capMat);
  capMesh.scale.y = 0.5; 
  capMesh.position.y = 0.1; 
  capMesh.userData = { isButton: true }; 
  buttonGroup.add(capMesh);

  // Warning Ring
  const ringGeo = new THREE.TorusGeometry(3, 0.15, 16, 64);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
  const ringMesh = new THREE.Mesh(ringGeo, ringMat);
  ringMesh.rotation.x = Math.PI / 2;
  ringMesh.position.y = 0.05;
  buttonGroup.add(ringMesh);

  // --- 5. Text Assets ---
  const loader = new THREE.FontLoader();
  
  const textGroup = new THREE.Group();
  scene.add(textGroup);
  const textMeshes = [];
  const neonColors = [0x00ffff, 0xffaa00, 0x00ffff, 0xffaa00];

  loader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
    
    // 1. Create RIFT Title
    const textString = "RIFT";
    let xOffset = 0;
    const spacing = 1.5; 

    textString.split('').forEach((char, i) => {
      const geometry = new THREE.TextGeometry(char, {
        font: font,
        size: 7,
        height: 0.6,
        curveSegments: 12,
        bevelEnabled: true, 
        bevelThickness: 0.05, 
        bevelSize: 0.02, 
        bevelSegments: 3
      });
      geometry.computeBoundingBox();
      const width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
      const material = new THREE.MeshStandardMaterial({
        color: 0x000000, 
        emissive: neonColors[i],
        emissiveIntensity: 1.5, 
        roughness: 0.3,
        metalness: 0.9
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.x = xOffset;
      mesh.userData = { baseHex: neonColors[i], offset: i };
      textGroup.add(mesh);
      textMeshes.push(mesh);

      // Floor light (kept but reduced range since floor is matte)
      const floorLight = new THREE.PointLight(neonColors[i], 0.8, 10);
      floorLight.position.set(xOffset + width/2, -2, 4);
      textGroup.add(floorLight);

      xOffset += width + spacing;
    });

    const box = new THREE.Box3().setFromObject(textGroup);
    textGroup.position.x = -(box.max.x - box.min.x) / 2;
    textGroup.position.y = 2;

    // 2. Create BREACH Label
    const breachGeo = new THREE.TextGeometry("BREACH", {
      font: font,
      size: 0.8,
      height: 0.1,
      curveSegments: 5,
      bevelEnabled: false
    });
    breachGeo.computeBoundingBox();
    const bWidth = breachGeo.boundingBox.max.x - breachGeo.boundingBox.min.x;
    const breachMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
    const breachMesh = new THREE.Mesh(breachGeo, breachMat);
    breachMesh.position.set(-bWidth / 2, 0.5, 0.3); 
    breachMesh.rotation.x = -Math.PI / 2;
    capMesh.add(breachMesh);
  });

  // --- 6. Interaction ---
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let isHoveringButton = false;
  let isPressed = false;

  window.addEventListener('mousemove', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  });

  window.addEventListener('mousedown', () => {
    if (isHoveringButton) {
      isPressed = true;
      capMesh.position.y = -0.1; 
      setTimeout(() => {
        alert('>>> SYSTEM BREACH INITIATED <<<');
      }, 100);
    }
  });

  window.addEventListener('mouseup', () => {
    isPressed = false;
    capMesh.position.y = 0.1;
  });

  // --- 7. Animation Loop ---
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects([capMesh], false); 
    const wasHovering = isHoveringButton;
    isHoveringButton = intersects.length > 0;

    if (isHoveringButton !== wasHovering) {
      document.body.className = isHoveringButton ? 'hovering' : '';
    }

    if (isHoveringButton) {
      glitchPass.goWild = false; 
      // REDUCED HOVER FLICKER (50% reduction)
      const hoverPulse = Math.sin(t * 10) * 0.25 + 0.5; // Reduced amplitude
      capMat.emissive.setHex(0xff3333); 
      capMat.emissiveIntensity = 1.5 + hoverPulse * 0.5; // Reduced multiplier

      buttonGroup.scale.setScalar(1.05);
    } else {
      glitchPass.goWild = false;
      buttonGroup.scale.setScalar(1.0);
      
      // REDUCED IDLE FLICKER (50% reduction)
      const pulse = Math.sin(t * 3) * 0.5 + 0.5;
      capMat.emissive.setHex(0xff0000); 
      capMat.emissiveIntensity = 0.3 + (pulse * 0.3); // Reduced from 0.6
      
      ringMesh.rotation.z = t * 0.5;
    }

    if(textGroup) {
      textGroup.position.y = 2 + Math.sin(t * 0.8) * 0.2;
      textMeshes.forEach(mesh => {
         const hueShift = Math.sin(t * 0.5 + mesh.userData.offset) * 0.1;
         const baseColor = new THREE.Color(mesh.userData.baseHex);
         const hsl = {};
         baseColor.getHSL(hsl);
         mesh.material.emissive.setHSL(hsl.h + hueShift, hsl.s, hsl.l);
         
         const extraEnergy = isHoveringButton ? 0.5 : 0.0;
         // REDUCED TEXT FLICKER (50% reduction)
         // Amplitude changed from 0.3 to 0.15
         mesh.material.emissiveIntensity = 1.5 + Math.sin(t * 2) * 0.15 + extraEnergy;
      });
    }

    if (gridHelper) gridHelper.position.z = (t * 2) % 10;

    if (!isHoveringButton) {
       // REDUCED GLITCH FREQUENCY
       // Changed from 0.998 to 0.999 (Halved probability)
       if (Math.random() > 0.999) {
         glitchPass.curF = Math.floor(Math.random() * 10);
       }
    }

    camera.lookAt(0, 0, 0);
    composer.render();
  }

  animate();

  window.addEventListener('resize', () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
    composer.setSize(w, h);
    bloomPass.resolution.set(w, h);
  });

</script>
</body>
</html>